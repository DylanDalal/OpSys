// Split input into the command and its arguments. Assumes one-word command.
		const char* cmd = tokens->items[0];
		char** args = tokens->items + 1;

		// Get the $PATH string and copy it to make it editable.
		const char* temp = getenv("PATH");
		char* full = malloc(sizeof(char) * (strlen(home) + 1));
		strcpy(full, temp);
		
		char* const parmList[] = { "/bin",  NULL};
		
		// split up this string after every :			
		char* dir;
		dir = malloc(strlen(path) + strlen(hom) + 1);
		char* token = strtok(hom, ":");
		int i = 0;
		while (token != NULL) {
						//parmList[i] = token;
						
			i++;
						//strcat(dir, token);
						//strcat(dir, "\n");
						// 
						//printf(" %s\n", token); 
		token = strtok(NULL, ":");
		}		
		execvp(tokens->items[0], parmList);
		tokens->items[i] = dir;
				
		// Split $PATH string into tokenized expression on the colon.
		char* path = strtok(full, ":");

		// "found" variable updates to both stop the while loop and
		int found = 0;

		// Cycle through $PATH tokens to find the function.
		while(path != NULL && found == 0) {
					// Create "Copy" path that holds the concatenated possible path to the command.
			char* copy = malloc(strlen(path) + strlen(cmd) + 5);
			strcpy(copy, path);
			strcat(copy, "/");
			strcat(copy, cmd);
			printf("%s", copy); // Error checking to show the paths

			// Execv returns -1 if it fails
			if (execvp(path, args) != -1) {
				printf("Found command at %s", path); // error checking
				found = 1;
			} else {
				printf("    no\n"); // error checking
			}
					//free(copy);
			path = strtok(NULL, ":");
		}

		if (found == 0) {
			printf("Command '%s' not found.\n", cmd);
		}

//
//			//strcpy(dir, hom);
//			//strcat(dir, "/");
//			//strcat(dir, path);
//
//		tokens->items[i] = dir;